{"version":3,"file":"intl-messageformat.min.js","sources":["../src/compiler.ts","../src/core.ts","../src/index.ts","../src/en.ts"],"sourcesContent":["/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\nimport {\n  MessageFormatPattern,\n  MessageTextElement,\n  ArgumentElement,\n  PluralFormat as ParserPluralFormat,\n  SelectFormat as ParserSelectFormat\n} from \"intl-messageformat-parser\";\n\nexport interface Formats {\n  number: Record<string, Intl.NumberFormatOptions>;\n  date: Record<string, Intl.DateTimeFormatOptions>;\n  time: Record<string, Intl.DateTimeFormatOptions>;\n}\n\nexport type Pattern =\n  | string\n  | PluralOffsetString\n  | PluralFormat\n  | SelectFormat\n  | StringFormat;\n\nexport default class Compiler {\n  private locales: string | string[] = [];\n  private formats: Formats = {\n    number: {},\n    date: {},\n    time: {}\n  };\n  private pluralNumberFormat: Intl.NumberFormat | null = null;\n  private currentPlural: ArgumentElement | null | undefined = null;\n  private pluralStack: Array<ArgumentElement | null | undefined> = [];\n\n  constructor(locales: string | string[], formats: Formats) {\n    this.locales = locales;\n    this.formats = formats;\n  }\n\n  compile(ast: MessageFormatPattern): Pattern[] {\n    this.pluralStack = [];\n    this.currentPlural = null;\n    this.pluralNumberFormat = null;\n\n    return this.compileMessage(ast);\n  }\n\n  compileMessage(ast: MessageFormatPattern) {\n    if (!(ast && ast.type === \"messageFormatPattern\")) {\n      throw new Error('Message AST is not of type: \"messageFormatPattern\"');\n    }\n    const { elements } = ast;\n    const pattern = elements\n      .filter<MessageTextElement | ArgumentElement>(\n        (el): el is MessageTextElement | ArgumentElement =>\n          el.type === \"messageTextElement\" || el.type === \"argumentElement\"\n      )\n      .map(el =>\n        el.type === \"messageTextElement\"\n          ? this.compileMessageText(el)\n          : this.compileArgument(el)\n      );\n    if (pattern.length !== elements.length) {\n      throw new Error(\"Message element does not have a valid type\");\n    }\n\n    return pattern;\n  }\n\n  compileMessageText(element: MessageTextElement) {\n    // When this `element` is part of plural sub-pattern and its value contains\n    // an unescaped '#', use a `PluralOffsetString` helper to properly output\n    // the number with the correct offset in the string.\n    if (this.currentPlural && /(^|[^\\\\])#/g.test(element.value)) {\n      // Create a cache a NumberFormat instance that can be reused for any\n      // PluralOffsetString instance in this message.\n      if (!this.pluralNumberFormat) {\n        this.pluralNumberFormat = new Intl.NumberFormat(this.locales);\n      }\n\n      return new PluralOffsetString(\n        this.currentPlural.id,\n        (this.currentPlural.format as ParserPluralFormat).offset,\n        this.pluralNumberFormat,\n        element.value\n      );\n    }\n\n    // Unescape the escaped '#'s in the message text.\n    return element.value.replace(/\\\\#/g, \"#\");\n  }\n\n  compileArgument(element: ArgumentElement) {\n    const { format, id } = element;\n\n    if (!format) {\n      return new StringFormat(id);\n    }\n\n    const { formats, locales } = this;\n    switch (format.type) {\n      case \"numberFormat\":\n        return {\n          id,\n          format: new Intl.NumberFormat(locales, formats.number[format.style])\n            .format\n        };\n\n      case \"dateFormat\":\n        return {\n          id,\n          format: new Intl.DateTimeFormat(locales, formats.date[format.style])\n            .format\n        };\n\n      case \"timeFormat\":\n        return {\n          id,\n          format: new Intl.DateTimeFormat(locales, formats.time[format.style])\n            .format\n        };\n\n      case \"pluralFormat\":\n        return new PluralFormat(\n          id,\n          format.ordinal,\n          format.offset,\n          this.compileOptions(element),\n          locales\n        );\n\n      case \"selectFormat\":\n        return new SelectFormat(id, this.compileOptions(element));\n\n      default:\n        throw new Error(\"Message element does not have a valid format type\");\n    }\n  }\n\n  compileOptions(element: ArgumentElement) {\n    const format = element.format as ParserPluralFormat | ParserSelectFormat;\n    const { options } = format;\n    const optionsHash: Record<string, Array<Pattern>> = {};\n\n    // Save the current plural element, if any, then set it to a new value when\n    // compiling the options sub-patterns. This conforms the spec's algorithm\n    // for handling `\"#\"` syntax in message text.\n    this.pluralStack.push(this.currentPlural);\n    this.currentPlural = format.type === \"pluralFormat\" ? element : null;\n\n    var i, len, option;\n\n    for (i = 0, len = options.length; i < len; i += 1) {\n      option = options[i];\n\n      // Compile the sub-pattern and save it under the options's selector.\n      optionsHash[option.selector] = this.compileMessage(option.value);\n    }\n\n    // Pop the plural stack to put back the original current plural value.\n    this.currentPlural = this.pluralStack.pop();\n\n    return optionsHash;\n  }\n}\n\n// -- Compiler Helper Classes --------------------------------------------------\n\nabstract class Formatter {\n  public id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n  abstract format(value: string | number): string;\n}\n\nexport class StringFormat extends Formatter {\n  format(value: number | string) {\n    if (!value && typeof value !== \"number\") {\n      return \"\";\n    }\n\n    return typeof value === \"string\" ? value : String(value);\n  }\n}\n\nexport class PluralFormat {\n  public id: string;\n  private offset: number;\n  private options: Record<string, Pattern[]>;\n  private pluralRules: Intl.PluralRules;\n  constructor(\n    id: string,\n    useOrdinal: boolean,\n    offset: number,\n    options: Record<string, Pattern[]>,\n    locales: string | string[]\n  ) {\n    this.id = id;\n    this.offset = offset;\n    this.options = options;\n    this.pluralRules = new Intl.PluralRules(locales, {\n      type: useOrdinal ? \"ordinal\" : \"cardinal\"\n    });\n  }\n\n  getOption(value: number) {\n    const { options } = this;\n\n    const option =\n      options[\"=\" + value] ||\n      options[this.pluralRules.select(value - this.offset)];\n\n    return option || options.other;\n  }\n}\n\nexport class PluralOffsetString extends Formatter {\n  private offset: number;\n  private numberFormat: Intl.NumberFormat;\n  private string: string;\n  constructor(\n    id: string,\n    offset: number,\n    numberFormat: Intl.NumberFormat,\n    string: string\n  ) {\n    super(id);\n    this.offset = offset;\n    this.numberFormat = numberFormat;\n    this.string = string;\n  }\n\n  format(value: number) {\n    var number = this.numberFormat.format(value - this.offset);\n\n    return this.string\n      .replace(/(^|[^\\\\])#/g, \"$1\" + number)\n      .replace(/\\\\#/g, \"#\");\n  }\n}\n\nexport class SelectFormat {\n  public id: string;\n  private options: Record<string, Pattern[]>;\n  constructor(id: string, options: Record<string, Pattern[]>) {\n    this.id = id;\n    this.options = options;\n  }\n\n  getOption(value: string) {\n    var options = this.options;\n    return options[value] || options.other;\n  }\n}\n\nexport function isSelectOrPluralFormat(\n  f: any\n): f is SelectFormat | PluralFormat {\n  return !!f.options;\n}\n","/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n/* jslint esnext: true */\n\nimport Compiler, { Formats, isSelectOrPluralFormat, Pattern } from \"./compiler\";\nimport parser, { MessageFormatPattern } from \"intl-messageformat-parser\";\n\n// -- MessageFormat --------------------------------------------------------\n\nexport default class MessageFormat<T> {\n  public static defaultLocale: string;\n  private static __localeData__: Record<string, any>;\n  // Default format options used as the prototype of the `formats` provided to the\n  // constructor. These are used when constructing the internal Intl.NumberFormat\n  // and Intl.DateTimeFormat instances.\n  public static readonly formats: Formats = {\n    number: {\n      currency: {\n        style: \"currency\"\n      },\n\n      percent: {\n        style: \"percent\"\n      }\n    },\n\n    date: {\n      short: {\n        month: \"numeric\",\n        day: \"numeric\",\n        year: \"2-digit\"\n      },\n\n      medium: {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\"\n      },\n\n      long: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n      },\n\n      full: {\n        weekday: \"long\",\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n      }\n    },\n\n    time: {\n      short: {\n        hour: \"numeric\",\n        minute: \"numeric\"\n      },\n\n      medium: {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        second: \"numeric\"\n      },\n\n      long: {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        second: \"numeric\",\n        timeZoneName: \"short\"\n      },\n\n      full: {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        second: \"numeric\",\n        timeZoneName: \"short\"\n      }\n    }\n  };\n  private _locale: string;\n  private pattern: ReturnType<Compiler[\"compile\"]>;\n  private message: string;\n  constructor(\n    message: string,\n    locales?: string | string[],\n    overrideFormats?: Formats\n  ) {\n    // Parse string messages into an AST.\n    var ast =\n      typeof message === \"string\" ? MessageFormat.__parse(message) : message;\n\n    if (!(ast && ast.type === \"messageFormatPattern\")) {\n      throw new TypeError(\"A message must be provided as a String or AST.\");\n    }\n\n    // Creates a new object with the specified `formats` merged with the default\n    // formats.\n    const formats = mergeConfigs(MessageFormat.formats, overrideFormats);\n\n    // Defined first because it's used to build the format pattern.\n    this._locale = this._resolveLocale(locales || []);\n\n    // Compile the `ast` to a pattern that is highly optimized for repeated\n    // `format()` invocations. **Note:** This passes the `locales` set provided\n    // to the constructor instead of just the resolved locale.\n    this.pattern = this._compilePattern(ast, locales || [], formats);\n\n    this.message = message;\n  }\n  static __addLocaleData(data: { locale: string; [locale: string]: any }) {\n    if (!(data && data.locale)) {\n      throw new Error(\n        \"Locale data provided to IntlMessageFormat is missing a \" +\n          \"`locale` property\"\n      );\n    }\n\n    MessageFormat.__localeData__[data.locale.toLowerCase()] = data;\n  }\n\n  public static __parse = parser.parse;\n\n  // \"Bind\" `format()` method to `this` so it can be passed by reference like\n  // the other `Intl` APIs.\n  format = (values: Record<string, string | number>) => {\n    try {\n      return this._format(this.pattern, values);\n    } catch (e) {\n      if (e.variableId) {\n        throw new Error(\n          \"The intl string context variable '\" +\n            e.variableId +\n            \"'\" +\n            \" was not provided to the string '\" +\n            this.message +\n            \"'\"\n        );\n      } else {\n        throw e;\n      }\n    }\n  };\n  resolvedOptions() {\n    return { locale: this._locale };\n  }\n\n  _resolveLocale(locales: string | string[]): string {\n    if (typeof locales === \"string\") {\n      locales = [locales];\n    }\n\n    // Create a copy of the array so we can push on the default locale.\n    locales = (locales || []).concat(MessageFormat.defaultLocale);\n\n    var localeData = MessageFormat.__localeData__;\n    var i, len, localeParts, data;\n\n    // Using the set of locales + the default locale, we look for the first one\n    // which that has been registered. When data does not exist for a locale, we\n    // traverse its ancestors to find something that's been registered within\n    // its hierarchy of locales. Since we lack the proper `parentLocale` data\n    // here, we must take a naive approach to traversal.\n    for (i = 0, len = locales.length; i < len; i += 1) {\n      localeParts = locales[i].toLowerCase().split(\"-\");\n\n      while (localeParts.length) {\n        data = localeData[localeParts.join(\"-\")];\n        if (data) {\n          // Return the normalized locale string; e.g., we return \"en-US\",\n          // instead of \"en-us\".\n          return data.locale;\n        }\n\n        localeParts.pop();\n      }\n    }\n\n    var defaultLocale = locales.pop();\n    throw new Error(\n      \"No locale data has been added to IntlMessageFormat for: \" +\n        locales.join(\", \") +\n        \", or the default locale: \" +\n        defaultLocale\n    );\n  }\n  _compilePattern(\n    ast: MessageFormatPattern,\n    locales: string | string[],\n    formats: Formats\n  ) {\n    var compiler = new Compiler(locales, formats);\n    return compiler.compile(ast);\n  }\n  _format(pattern: Pattern[], values: Record<string, string | number>) {\n    var result = \"\",\n      i,\n      len,\n      part,\n      id,\n      value,\n      err;\n\n    for (i = 0, len = pattern.length; i < len; i += 1) {\n      part = pattern[i];\n\n      // Exist early for string parts.\n      if (typeof part === \"string\") {\n        result += part;\n        continue;\n      }\n\n      id = part.id;\n\n      // Enforce that all required values are provided by the caller.\n      if (!(values && id in values)) {\n        throw new FormatError(\"A value must be provided for: \" + id, id);\n      }\n\n      value = values[id];\n\n      // Recursively format plural and select parts' option — which can be a\n      // nested pattern structure. The choosing of the option to use is\n      // abstracted-by and delegated-to the part helper object.\n      if (isSelectOrPluralFormat(part)) {\n        result += this._format(part.getOption(value as any), values);\n      } else {\n        result += part.format(value as any);\n      }\n    }\n\n    return result;\n  }\n}\n\nfunction mergeConfig(c1: Record<string, object>, c2: Record<string, object>) {\n  if (!c2) {\n    return c1;\n  }\n  return {\n    ...(c1 || {}),\n    ...(c2 || {}),\n    ...Object.keys(c1).reduce((all: Record<string, object>, k) => {\n      all[k] = {\n        ...c1[k],\n        ...(c2[k] || {})\n      };\n      return all;\n    }, {})\n  };\n}\n\nfunction mergeConfigs<T extends Formats>(\n  defaultConfig: Formats,\n  configs?: T\n): Formats {\n  if (!configs) {\n    return defaultConfig;\n  }\n\n  return {\n    ...defaultConfig,\n    date: mergeConfig(defaultConfig.date, configs.date)\n  };\n}\n\nclass FormatError extends Error {\n  public readonly variableId?: string;\n  constructor(msg?: string, variableId?: string) {\n    super(msg);\n    this.variableId = variableId;\n  }\n}\n","/* jslint esnext: true */\n\nimport IntlMessageFormat from \"./core\";\nimport defaultLocale from \"./en\";\n\nIntlMessageFormat.__addLocaleData(defaultLocale);\nIntlMessageFormat.defaultLocale = \"en\";\n\nexport default IntlMessageFormat;\n","/* @generated */\nexport default {\"locale\":\"en\"};\n"],"names":["Compiler","ast","this","pluralStack","currentPlural","pluralNumberFormat","compileMessage","type","Error","elements","pattern","filter","el","map","_this","compileMessageText","compileArgument","length","element","test","value","Intl","NumberFormat","locales","PluralOffsetString","id","format","offset","replace","StringFormat","formats","number","style","DateTimeFormat","date","time","PluralFormat","ordinal","compileOptions","SelectFormat","i","len","option","options","optionsHash","push","selector","pop","tslib_1.__extends","Formatter","String","pluralRules","select","other","useOrdinal","PluralRules","numberFormat","string","_super","MessageFormat","data","locale","__localeData__","toLowerCase","_locale","concat","defaultLocale","localeParts","localeData","split","join","compile","values","part","result","FormatError","_format","getOption","currency","percent","short","month","day","year","medium","long","full","weekday","hour","minute","second","timeZoneName","parser","parse","message","overrideFormats","e","variableId","__parse","TypeError","defaultConfig","configs","c1","c2","Object","keys","reduce","all","k","mergeConfig","mergeConfigs","_resolveLocale","_compilePattern","msg","__addLocaleData"],"mappings":"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"}